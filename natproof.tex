\section{Natural Number Proofs}

We now explore the kernel of this work : proofs. Here we open with the perhaps
the most natural kind of proof one would expect, that of laws over the
inductively defined natural numbers. As a proposed foundational alternative to
mathematics, dependent type theories allow types to depend on terms, and
therefore allows propositions which include terms to be encoded as types.

In the simple type theory example, we included \emph{types} and
\emph{expressions} as distinct syntactic categories, whereby the linearization
of a type can't possibly call the linearization of a term. We now experiment
with a small dependently typed programming language with only $\Pi$ types. The
big difference for such a simple fragment like Natural Numbers in the dependent
setting is the fact that the recursion principle becomes an induction principle.
The types of a sub-expression being with a recursive call may depend on
the values being computing, and therefore extra work is required because the
type-checker has to deal with a much more sensitive notion of type.

A dependent type theorist will assert that every time mathematicians use a
notion like $\mathbb{R}^n$, they are implicitly quantifying over the natural
numbers, and therefore are referring to a type, not a \emph{set} of vector spaces.
There are many more elaborate examples, but because this notation is ubiquitous,
we note that the type theorist would not be satisfied with many expressions
from real analysis, because they assert things about $\mathbb{R}^n$ all the time
without ever proving anything by induction over the numbers being referenced.
Perhaps this seems pedantic, but it highlights a large gap between the
type-theorists syntactic approach to mathematics and the mathematicians focus on
the domain semantics of her field of interest.

Delaying a more in depth discussion of equality [ref later section], we here
assert that one proves equality in Agda by finding something that is \emph{irrefutably
equal} to itself, where the notion of irrefutably is in some sense gave birth to
subject matter of higher type theory.  Taking this for granted, we begin by
looking at one of the simplest natural numbers proof's : that addition is
associative.

We define addition in Agda by recursion on the first argument, and notice that
the sum of two natural numbers is always a natural number. Therefore, agda has
the capacity to always compute the sum of two given natural number, via the defining
equations, and indeed $2+2=4$ is irrefutably true. Additionally, we know that,
any $0$ added to a number is always that number, and this works both ways.

\input{latex/nproof}

[sum, 2 + 2 = 4, stuck]

We now encode the type which encodes the proposition which says some number $0$
plus some number is prepositionally equal to that number. And Agda is able to
computes its evidence via the definition of addition. Yet, the novice Agda
programmer will run into the fact that any number added to $0$ is not
definitionally equal, i.e. that the defining equations don't give an automatic
way of universally validating this. We're stuck. 

Instead, one must use induction, which we show here by pattern matching.



However, because 





