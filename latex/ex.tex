
\begin{code}[hide]%
\>[0]\<%
\\
\>[0]\AgdaComment{-- \{-\# OPTIONS --omega-in-omega --type-in-type \#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{ex}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{variable}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaGeneralizable{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaGeneralizable{D}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaGeneralizable{stuff}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{definition-body}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{T}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{L}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{E}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{C}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{proof}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{L}\<%
\\
\>[0]\AgdaFunction{proof}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{zero'}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{corollaryStuff}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{proofNeedingLemma}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{a‚Ñï}\<%
\\
\>[0]\AgdaFunction{proofNeedingLemma}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{x‚ÇÅ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaInductiveConstructor{zero'}\<%
\\
\>[0]\<%
\end{code}

To give a brief overview of the syntax Agda uses for judgements, namely $T :
Set$ means $T$ is a Type, $t : T$ means a term $t$ has type $T$, and $t = t'$
means $t$ is defined to be equal to $t'$. Let's compare it to those keywords
ubiquitous in mathematics \autoref{fig:M1}, and show how those are represented in Agda directly below. Warrick

\begin{figure}[H]
\centering

\begin{itemize}
\item Axiom
\item Definition
\item Lemma
\item Theorem
\item Proof
\item Corollary
\item Example
\end{itemize}

\caption{FOL vs MLTT} \label{fig:M1}
\end{figure}

\begin{code}%
\>[0]\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{inductiveType}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\AgdaSpace{}%
\AgdaComment{--Formation Rule}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{constructr}%
\>[14]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{inductiveType}\AgdaSpace{}%
\AgdaComment{--Introduction Rules}\<%
\\
%
\>[2]\AgdaInductiveConstructor{constructr'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{inductiveType}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{postulate}%
\>[12]\AgdaComment{-- Axiom}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{axiom}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{A}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{definition}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{stuff}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaComment{--Definition}\<%
\\
\>[0]\AgdaFunction{definition}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{definition-body}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{theorem}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{T}%
\>[16]\AgdaComment{-- Theorem Statement}\<%
\\
\>[0]\AgdaFunction{theorem}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{proofNeedingLemma}\AgdaSpace{}%
\AgdaFunction{lemma}\AgdaSpace{}%
\AgdaComment{-- Proof}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{lemma}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{L}%
\>[18]\AgdaComment{-- Lemma Statement}\<%
\\
%
\>[4]\AgdaFunction{lemma}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{proof}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{corollary}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{corollaryStuff}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaFunction{C}\<%
\\
\>[0]\AgdaFunction{corollary}\AgdaSpace{}%
\AgdaBound{coro-term}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{theorem}\AgdaSpace{}%
\AgdaBound{coro-term}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{example}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{E}%
\>[16]\AgdaComment{-- Example Statement}\<%
\\
\>[0]\AgdaFunction{example}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{proof}\<%
\\
\>[0]\<%
\end{code}


Formation rules, are given by the first line of the data declaration, followed
by some number of constructors which correspond to the introduction forms of the
type being defined.

Therefore, to define a type  Booleans, ùîπ, we present for the formation rule

\[
  \begin{prooftree-- }
    \infer1[]{ \vdash ùîπ : {\rm type}}
  \end{prooftree}
\]

along with two introduction rules for the bits,

\[
  \begin{prooftree}
    \infer1[]{ \Gamma \vdash true : ùîπ  }
  \end{prooftree}
  \quad \quad
  \begin{prooftree}
    \infer1[]{ \Gamma \vdash false : ùîπ  }
  \end{prooftree}
\]

Agda's allows us to succintly put these together as

\begin{code}%
\>[0]\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\<%
\\
%
\>[2]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\<%
\\
\>[0]\<%
\end{code}

Now we can define our first type, term judgement pair, and define, for instance,
the Boolean or, ‚à®. We detail the definition which is just a result of the
pattern match Agda performs when working interactively via holes in the emacs
mode, and that once one plays around with it, one recognizes both the beauty and
elegance in how Agda facilitates programming. The colon
reresents the judgmenet that ‚à® is a type, whereas the equality symbol denotes
the fact that ‚à® is computationally equal to the subsequent expression over the
given inputs. Once one has made this equality judgement, agda can normalize the
definitionally equal terms to the same normal form when defining subsequent
judgements.

The underscore denotes the placement of the arguement. We see the _‚à®_
constructor allows for more nuanced syntacic features out of the box than most
programming languages provide, like unicode and various ways of mixing
arguements into the function. This is interesting from the emph{concrete syntax}
perspective as the arguement placement, and symbolic expressiveness gives Agda a
syntax more familiar to the mathematician.

\begin{code}%
\>[0]\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}‚à®\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\<%
\\
\>[0]\AgdaInductiveConstructor{true}%
\>[6]\AgdaOperator{\AgdaFunction{‚à®}}\AgdaSpace{}%
\AgdaBound{b}%
\>[14]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à®}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}%
\>[14]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
\>[0]\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{‚à®}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\<%
\\
\>[0]\<%
\end{code}


As the elimination forms are deriveable from the introduction rules, the
computation rules can then be extracted by via the harmonious relationship
between the introduction and elmination forms \cite{pfenningHar}. Agda's pattern
matching is equivalent to the deriveable dependently typed elimination forms
\cite{coqPat}, and one can simply pattern match on a boolean, producing multiple
lines for each constructor of the variable's type, to extract the classic
recursion principle for Booleans.

\[
  \begin{prooftree}
    \hypo{Ãå\Gamma \vdash A : {\rm type} }
    \hypo{\Gamma \vdash b : ùîπ }
    \hypo{\Gamma \vdash a1 : A}
    \hypo{\Gamma \vdash a2 : A }
    \infer4[]{\Gamma \vdash boolrec\{a1;a2\}(b) : A }
  \end{prooftree}
\]


\begin{code}%
\>[0]\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{if\AgdaUnderscore{}then\AgdaUnderscore{}else\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaBound{a1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaBound{a2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a1}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaBound{a1}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaBound{a2}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a2}\<%
\\
\>[0]\<%
\end{code}

The Agda code reflects this, and we see the first use of parametric
polymorphism, namely, that we can extract a member of some arbtitrary type \term{A} from a boolean
value given two possibly equal values members of \term{A}.

This polymorphism therefore allows one to implement simple programs like the
boolean not, ~, via the eliminator. More interestingly, one can work with
functionals, or higher order functions which take functions as arguements and
return functions as well. We also notice in \term{functionalExample} below that
one can work directly with lambda's if the typechecker infers a function type
for a hole.

\begin{code}%
\>[0]\<%
\\
\>[0]\AgdaFunction{\textasciitilde{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\<%
\\
\>[0]\AgdaFunction{\textasciitilde{}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaInductiveConstructor{false}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaInductiveConstructor{true}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{functionalExample}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ùîπ}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{ùîπ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{functionalExample}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{if}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{then}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{else}}\AgdaSpace{}%
\AgdaSymbol{Œª}\AgdaSpace{}%
\AgdaBound{b'}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{\textasciitilde{}}\AgdaSpace{}%
\AgdaBound{b'}\AgdaSymbol{)}\<%
\\
\>[0]\<%
\end{code}

This simple example

\begin{code}%
\>[0]\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{‚Üí}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{‚Ñïrec}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaDatatype{‚Ñï}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaBound{X}\<%
\\
\>[0]\AgdaFunction{‚Ñïrec}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{‚Ñïrec}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{‚Ñïrec}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- data List (A : Type) : Type where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- data Vector :}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- \textbackslash{}begin\{code\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- Type : Set‚ÇÅ}\<%
\\
\>[0]\AgdaComment{-- Type = Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- \textbackslash{}end\{code\}}\<%
\end{code}
