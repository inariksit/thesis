@article{ml1984, title={Per Martin-Löf. Intuitionistic type theory. (Notes by Giovanni Sambin of a series of lectures given in Padua, June 1980.) Studies in proof theory. Bibliopolis, Naples1984, ix   91 pp.}, volume={51}, DOI={10.2307/2273925}, number={4}, journal={Journal of Symbolic Logic}, publisher={Cambridge University Press}, author={Howard, W. A.}, year={1986}, pages={1075–1076}}

@incollection{kamp2011discourse,
  title={Discourse representation theory},
  author={Kamp, Hans and Van Genabith, Josef and Reyle, Uwe},
  booktitle={Handbook of philosophical logic},
  pages={125--394},
  year={2011},
  publisher={Springer}
}

@inproceedings{rantaLog,
  title={Translating between language and logic: what is easy and what is difficult},
  author={Ranta, Aarne},
  booktitle={International Conference on Automated Deduction},
  pages={5-25},
  year={2011},
  organization={Springer}
}


@article{mlMeanings,
	title = {On the Meanings of the Logical Constants and the Justifications of the Logical Laws},
	year = {1996},
	volume = {1},
	journal = {Nordic Journal of Philosophical Logic},
	author = {Per Martin{-}L\"of},
	number = {1},
	pages = {11--60},
	publisher = {Scandinavian University Press}
}

@article{mtac2,
author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and R\'{e}gis-Gianas, Yann and Dreyer, Derek},
title = {Mtac2: Typed Tactics for Backward Reasoning in Coq},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236773},
doi = {10.1145/3236773},
abstract = {Coq supports a range of built-in tactics, which are engineered primarily to support
backward reasoning. Starting from a desired goal, the Coq programmer can use these
tactics to manipulate the proof state interactively, applying axioms or lemmas to
break the goal into subgoals until all subgoals have been solved. Additionally, it
provides support for tactic programming via OCaml and Ltac, so that users can roll
their own custom proof automation routines. Unfortunately, though, these tactic languages
share a significant weakness. They do not offer the tactic programmer any static guarantees
about the soundness of their custom tactics, making large tactic developments difficult
to maintain. To address this limitation, Ziliani et al. previously proposed Mtac,
a new typed approach to custom proof automation in Coq which provides the static guarantees
that OCaml and Ltac are missing. However, despite its name, Mtac is really more of
a metaprogramming language than it is a full-blown tactic language: it misses an essential
feature of tactic programming, namely the ability to directly manipulate Coq’s proof
state and perform backward reasoning on it. In this paper, we present Mtac2, a next-generation
version of Mtac that combines its support for typed metaprogramming with additional
support for the programming of backward-reasoning tactics in the style of Ltac. In
so doing, Mtac2 introduces a novel feature in tactic programming languages—what we
call typed backward reasoning. With this feature, Mtac2 is capable of statically ruling
out several classes of errors that would otherwise remain undetected at tactic definition
time. We demonstrate the utility of Mtac2’s typed tactics by porting several tactics
from a large Coq development, the Iris Proof Mode, from Ltac to Mtac2.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {78},
numpages = {31},
keywords = {Metaprogramming, Dependent Types, Theorem Proving, Tactic Languages, Coq}
}

@inproceedings{coqAlec,
author = {Pit-Claudel, Cl\'{e}ment},
title = {Untangling Mechanized Proofs},
year = {2020},
isbn = {9781450381765},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3426425.3426940},
doi = {10.1145/3426425.3426940},
abstract = {Proof assistants like Coq, Lean, or HOL4 rely heavily on stateful meta-programs called
scripts to assemble proofs. Unlike pen-and-paper proofs, proof scripts only describe
the steps to take (induct on x, apply a theorem, …), not the states that these steps
lead to; as a result, plain proof scripts are essentially incomprehensible without
the assistance of an interactive user interface able to run the script and show the
corresponding proof states. Until now, the standard process to communicate a proof
without forcing readers to execute its script was to manually copy-paste intermediate
proof states into the script, as source code comments — a tedious and error-prone
exercise. Additional prose (such as for a book or tutorial) was likewise embedded
in comments, preserving executability at the cost of a mediocre text-editing experience.
This paper describes a new approach to the development and dissemination of literate
proof scripts, with a focus on the Coq proof assistant. Specifically, we describe
two contributions: a compiler that interleaves Coq’s output with the original proof
script to produce interactive webpages that are complete, self-contained presentations
of Coq proofs; and a new literate programming toolkit that allows authors to switch
seamlessly between prose- and code-oriented views of the same sources, by translating
back and forth between reStructuredText documents and literate Coq source files. In
combination, these tools offer a new way to write, communicate, and preserve proofs,
combining the flexibility of procedural proof scripts and the intelligibility of declarative
proofs.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Software Language Engineering},
pages = {155–174},
numpages = {20},
keywords = {proof presentation, proof browsing, formal verification, literate programming},
location = {Virtual, USA},
series = {SLE 2020}
}

@Book{rantaTT,
  author = {Ranta , Aarne}, 
  title = {{gf-contrib/typetheory}},
  year = 2013,
  publisher = {\url{https://github.com/GrammaticalFramework/gf-contrib/tree/master/typetheory}}
}

@Book{warrickHarper,
  author = {Macmillan , Warrick}, 
  title = {{GF-Typechecker}},
  year = 2020,
  publisher = {\url{https://github.com/wmacmil/GF_Typechecker}}
}


@article{rantaForsberg,
author = {Forsberg, Markus and Ranta, Aarne},
title = {Functional Morphology},
year = {2004},
issue_date = {September 2004},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {39},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1016848.1016879},
doi = {10.1145/1016848.1016879},
abstract = {This paper presents a methodology for implementing natural language morphology in
the functional language Haskell. The main idea behind is simple: instead of working
with untyped regular expressions, which is the state of the art of morphology in computational
linguistics, we use finite functions over hereditarily finite algebraic datatypes.
The definitions of these datatypes and functions are the language-dependent part of
the morphology. The language-independent part consists of an untyped dictionary format
which is used for synthesis of word forms, and a decorated trie, which is used for
analysis.Functional Morphology builds on ideas introduced by Huet in his computational
linguistics toolkit Zen, which he has used to implement the morphology of Sanskrit.
The goal has been to make it easy for linguists, who are not trained as functional
programmers, to apply the ideas to new languages. As a proof of the productivity of
the method, morphologies for Swedish, Italian, Russian, Spanish, and Latin have already
been implemented using the library. The Latin morphology is used as a running example
in this article.},
journal = {SIGPLAN Not.},
month = sep,
pages = {213–223},
numpages = {11},
keywords = {finite functions, functional programming, linguistics, morphological description, embedded languages}
}

@article{ranta_2004, title={Grammatical Framework}, volume={14}, DOI={10.1017/S0956796803004738}, number={2}, journal={Journal of Functional Programming}, publisher={Cambridge University Press}, author={RANTA, AARNE}, year={2004}, pages={145–189}}

@article{ljunglof2004expressivity,
  title={Expressivity and complexity of the Grammatical Framework},
  author={Ljungl{\"o}f, Peter},
  year={2004}
}

@inproceedings{alfaGF,
author = {Hallgren, Thomas and Ranta, Aarne},
title = {An Extensible Proof Text Editor},
year = {2000},
isbn = {3540412859},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {The paper presents an extension of the proof editor Alfa with natural-language input
and output. The basis of the new functionality is an automatic translation to syntactic
structures that are closer to natural language than the type-theoretical syntax of
Alfa. These syntactic structures are mapped into texts in languages such as English,
French, and Swedish. In this way, every theory, definition, proposition, and proof
in Alfa can be translated into a text in any of these languages. The translation is
defined for incomplete proof objects as well, so that a text with "holes" (i.e. metavariables)
in it can be viewed simultaneously with a formal proof constructed. The mappings into
natural language also work in the parsing direction, so that input can be given to
the proof editor in a natural language.The natural-language interface is implemented
using the Grammatical Framework GF, so that it is possible to change and extend the
interface without recompiling the proof editor. Such extensions can be made on two
dimensions: by adding new target languages, and by adding theory-specific grammatical
annotations to make texts more idiomatic.},
booktitle = {Proceedings of the 7th International Conference on Logic for Programming and Automated Reasoning},
pages = {70–84},
numpages = {15},
location = {Reunion Island, France},
series = {LPAR'00}
}

@InProceedings{ranta93,
author="Ranta, Aarne",
editor="Barendregt, Henk
and Nipkow, Tobias",
title="Type theory and the informal language of mathematics",
booktitle="Types for Proofs and Programs",
year="1994",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="352--365",
isbn="978-3-540-48440-0"
}

@Inbook{Montague1973,
author="Montague, Richard",
editor="Hintikka, K. J. J.
and Moravcsik, J. M. E.
and Suppes, P.",
title="The Proper Treatment of Quantification in Ordinary English",
bookTitle="Approaches to Natural Language: Proceedings of the 1970 Stanford Workshop on Grammar and Semantics",
year="1973",
publisher="Springer Netherlands",
address="Dordrecht",
pages="221--242",
abstract="The aim of this paper is to present in a rigorous way the syntax and semantics of a certain fragment of a certain dialect of English. For expository purposes the fragment has been made as simple and restricted as it can be while accommodating all the more puzzling cases of quantification and reference with which I am acquainted.1",
isbn="978-94-010-2506-5",
doi="10.1007/978-94-010-2506-5_10",
url="https://doi.org/10.1007/978-94-010-2506-5_10"
}

@InProceedings{luoCNs,
author="Luo, Zhaohui",
editor="B{\'e}chet, Denis
and Dikovsky, Alexander",
title="Common Nouns as Types",
booktitle="Logical Aspects of Computational Linguistics",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="173--185",
abstract="When modern type theories are employed for formal semantics, common nouns (CNs) are interpreted as types, not as predicates. Although this brings about some technical advantages, it is worthwhile to ask: what is special about CNs that merits them to be interpreted as types? We discuss the observation made by Geach that, unlike other lexical categories, CNs have criteria of identity, a component of meaning that makes it legitimate to compare, count and quantify. This is closely related to the notion of set (type) in constructive mathematics, where a set (type) is not given solely by specifying its objects, but together with an equality between its objects, and explains and justifies to some extent why types are used to interpret CNs in modern type theories. It is shown that, in order to faithfully interpret modified CNs as $\Sigma$-types so that the associated criteria of identity can be captured correctly, it is important to assume proof irrelevance in type theory. We shall also briefly discuss a proposal to interpret mass noun phrases as types in a uniform approach to the semantics of CNs.",
isbn="978-3-642-31262-5"
}

@book{theunivalentfoundationsprogram-homotopytypetheory-2013,
  title = {Homotopy Type Theory: Univalent Foundations of Mathematics},
  shorttitle = {Homotopy Type Theory},
  author = {{The Univalent foundations program} and {Institute for advanced study (Princeton}, N.J.)},
  year = {2013},
  annotation = {OCLC: 1028552960},
  language = {English}
}

@InProceedings{surveyLang,
author="Kaliszyk, Cezary
and Rabe, Florian",
editor="Benzm{\"u}ller, Christoph
and Miller, Bruce",
title="A Survey of Languages for Formalizing Mathematics",
booktitle="Intelligent Computer Mathematics",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="138--156",
abstract="In order to work with mathematical content in computer systems, it is necessary to represent it in formal languages. Ideally, these are supported by tools that verify the correctness of the content, allow computing with it, and produce human-readable documents. These goals are challenging to combine and state-of-the-art tools typically have to make difficult compromises.",
isbn="978-3-030-53518-6"
}

@misc{aarneHott,
author = {Aarne Ranta},
title = { Translating Homotopy Type Theory in Grammatical Framework },
publisher= { Stockholm Mathematics Seminar },
year = 2014
}


@misc{ltac2,
author = {Pierre-Marie Pédrot},
title = { Ltac2 : Tactical Warfare},
publisher= { POPL },
year = 2021
}

@book{frege79,
  author =    {Gottlob Frege},
  title =     {Begrisschrift},
  publisher = {Halle},
  year =      1879}

@book{Chomsky57,
  author = {Noam Chomsky},
  doi = {doi:10.1515/9783110218329},
  url = {https://doi.org/10.1515/9783110218329},
  title = {Syntactic Structures},
  year = {2009},
  publisher = {De Gruyter Mouton}
}

@book{ranta1994type,
  title={Type-theoretical Grammar},
  author={Ranta, A. and Ranta, D.P.A.},
  isbn={9780198538578},
  lccn={lc94038911},
  series={Indices (Claredon)},
  url={https://books.google.se/books?id=A5m13eGOcqYC},
  year={1994},
  publisher={Clarendon Press}
}

@misc{avigad2015mathematics,
      title={Mathematics and language}, 
      author={Jeremy Avigad},
      year={2015},
      eprint={1505.07238},
      archivePrefix={arXiv},
      primaryClass={math.HO}
}
